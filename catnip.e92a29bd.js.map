{"version":3,"sources":["../src/lib/directive.ts","../src/lib/dom.ts","../src/lib/part.ts","../src/lib/template.ts","../src/lib/template-instance.ts","../src/lib/template-result.ts","../src/lib/parts.ts","../src/lib/default-template-processor.ts","../src/lib/template-factory.ts","../src/lib/render.ts","src/lit-html.ts","scripts/models/input.ts","scripts/models/Frame.ts","scripts/models/LocalVariables.ts","scripts/models/native-methods.ts","scripts/models/OperandStack.ts","scripts/models/Frames.ts","scripts/parser/impl/constant-parser.ts","scripts/models/instructions/flow.ts","scripts/models/instructions/math.ts","scripts/models/instructions/objects.ts","scripts/models/instructions/others.ts","scripts/models/instructions/stacks.ts","scripts/models/instructions/index.ts","scripts/parser/impl/instruction-parser.ts","scripts/parser/sample.ts","scripts/templates/inputs.ts","scripts/templates/value.ts","scripts/templates/locals.ts","scripts/templates/stack.ts","scripts/templates/frame.ts","scripts/catnip.ts"],"names":[],"mappings":"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","file":"catnip.e92a29bd.js","sourceRoot":"../src","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {Part} from './part.js';\n\nconst directives = new WeakMap<object, true>();\n\n// tslint:disable-next-line:no-any\nexport type DirectiveFactory = (...args: any[]) => object;\n\nexport type DirectiveFn = (part: Part) => void;\n\n/**\n * Brands a function as a directive so that lit-html will call the function\n * during template rendering, rather than passing as a value.\n *\n * @param f The directive factory function. Must be a function that returns a\n * function of the signature `(part: Part) => void`. The returned function will\n * be called with the part object\n *\n * @example\n *\n * ```\n * import {directive, html} from 'lit-html';\n *\n * const immutable = directive((v) => (part) => {\n *   if (part.value !== v) {\n *     part.setValue(v)\n *   }\n * });\n * ```\n */\n// tslint:disable-next-line:no-any\nexport const directive = <F extends DirectiveFactory>(f: F): F =>\n    ((...args: unknown[]) => {\n      const d = f(...args);\n      directives.set(d, true);\n      return d;\n    }) as F;\n\nexport const isDirective = (o: unknown): o is DirectiveFn => {\n  return typeof o === 'function' && directives.has(o);\n};\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\ninterface MaybePolyfilledCe extends CustomElementRegistry {\n  polyfillWrapFlushCallback?: object;\n}\n\n/**\n * True if the custom elements polyfill is in use.\n */\nexport const isCEPolyfill = window.customElements !== undefined &&\n    (window.customElements as MaybePolyfilledCe).polyfillWrapFlushCallback !==\n        undefined;\n\n/**\n * Reparents nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), into another container (could be the same container), before\n * `beforeNode`. If `beforeNode` is null, it appends the nodes to the\n * container.\n */\nexport const reparentNodes =\n    (container: Node,\n     start: Node|null,\n     end: Node|null = null,\n     before: Node|null = null): void => {\n      let node = start;\n      while (node !== end) {\n        const n = node!.nextSibling;\n        container.insertBefore(node!, before as Node);\n        node = n;\n      }\n    };\n\n/**\n * Removes nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), from `container`.\n */\nexport const removeNodes =\n    (container: Node, startNode: Node|null, endNode: Node|null = null):\n        void => {\n          let node = startNode;\n          while (node !== endNode) {\n            const n = node!.nextSibling;\n            container.removeChild(node!);\n            node = n;\n          }\n        };\n","/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\n/**\n * The Part interface represents a dynamic part of a template instance rendered\n * by lit-html.\n */\nexport interface Part {\n  value: unknown;\n\n  /**\n   * Sets the current part value, but does not write it to the DOM.\n   * @param value The value that will be committed.\n   */\n  setValue(value: unknown): void;\n\n  /**\n   * Commits the current part value, cause it to actually be written to the DOM.\n   */\n  commit(): void;\n}\n\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange: object = {};\n\n/**\n * A sentinel value that signals a NodePart to fully clear its content.\n */\nexport const nothing = {};\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {TemplateResult} from './template-result.js';\n\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nexport const marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n\n/**\n * An expression marker used text-positions, multi-binding attributes, and\n * attributes with markup-like text values.\n */\nexport const nodeMarker = `<!--${marker}-->`;\n\nexport const markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n\n/**\n * Suffix appended to all bound attribute names.\n */\nexport const boundAttributeSuffix = '$lit$';\n\n/**\n * An updateable Template that tracks the location of dynamic parts.\n */\nexport class Template {\n  parts: TemplatePart[] = [];\n  element: HTMLTemplateElement;\n\n  constructor(result: TemplateResult, element: HTMLTemplateElement) {\n    this.element = element;\n    let index = -1;\n    let partIndex = 0;\n    const nodesToRemove: Node[] = [];\n    const _prepareTemplate = (template: HTMLTemplateElement) => {\n      const content = template.content;\n      // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n      // null\n      const walker = document.createTreeWalker(\n          content,\n          133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,\n          null,\n          false);\n      // Keeps track of the last index associated with a part. We try to delete\n      // unnecessary nodes, but we never want to associate two different parts\n      // to the same index. They must have a constant node between.\n      let lastPartIndex = 0;\n      while (walker.nextNode()) {\n        index++;\n        const node = walker.currentNode as Element | Comment | Text;\n        if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n          if ((node as Element).hasAttributes()) {\n            const attributes = (node as Element).attributes;\n            // Per\n            // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n            // attributes are not guaranteed to be returned in document order.\n            // In particular, Edge/IE can return them out of order, so we cannot\n            // assume a correspondance between part index and attribute index.\n            let count = 0;\n            for (let i = 0; i < attributes.length; i++) {\n              if (attributes[i].value.indexOf(marker) >= 0) {\n                count++;\n              }\n            }\n            while (count-- > 0) {\n              // Get the template literal section leading up to the first\n              // expression in this attribute\n              const stringForPart = result.strings[partIndex];\n              // Find the attribute name\n              const name = lastAttributeNameRegex.exec(stringForPart)![2];\n              // Find the corresponding attribute\n              // All bound attributes have had a suffix added in\n              // TemplateResult#getHTML to opt out of special attribute\n              // handling. To look up the attribute value we also need to add\n              // the suffix.\n              const attributeLookupName =\n                  name.toLowerCase() + boundAttributeSuffix;\n              const attributeValue =\n                  (node as Element).getAttribute(attributeLookupName)!;\n              const strings = attributeValue.split(markerRegex);\n              this.parts.push({type: 'attribute', index, name, strings});\n              (node as Element).removeAttribute(attributeLookupName);\n              partIndex += strings.length - 1;\n            }\n          }\n          if ((node as Element).tagName === 'TEMPLATE') {\n            _prepareTemplate(node as HTMLTemplateElement);\n          }\n        } else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n          const data = (node as Text).data!;\n          if (data.indexOf(marker) >= 0) {\n            const parent = node.parentNode!;\n            const strings = data.split(markerRegex);\n            const lastIndex = strings.length - 1;\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            for (let i = 0; i < lastIndex; i++) {\n              parent.insertBefore(\n                  (strings[i] === '') ? createMarker() :\n                                        document.createTextNode(strings[i]),\n                  node);\n              this.parts.push({type: 'node', index: ++index});\n            }\n            // If there's no text, we must insert a comment to mark our place.\n            // Else, we can trust it will stick around after cloning.\n            if (strings[lastIndex] === '') {\n              parent.insertBefore(createMarker(), node);\n              nodesToRemove.push(node);\n            } else {\n              (node as Text).data = strings[lastIndex];\n            }\n            // We have a part for each match found\n            partIndex += lastIndex;\n          }\n        } else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {\n          if ((node as Comment).data === marker) {\n            const parent = node.parentNode!;\n            // Add a new marker node to be the startNode of the Part if any of\n            // the following are true:\n            //  * We don't have a previousSibling\n            //  * The previousSibling is already the start of a previous part\n            if (node.previousSibling === null || index === lastPartIndex) {\n              index++;\n              parent.insertBefore(createMarker(), node);\n            }\n            lastPartIndex = index;\n            this.parts.push({type: 'node', index});\n            // If we don't have a nextSibling, keep this node so we have an end.\n            // Else, we can remove it to save future costs.\n            if (node.nextSibling === null) {\n              (node as Comment).data = '';\n            } else {\n              nodesToRemove.push(node);\n              index--;\n            }\n            partIndex++;\n          } else {\n            let i = -1;\n            while ((i = (node as Comment).data!.indexOf(marker, i + 1)) !==\n                   -1) {\n              // Comment node has a binding marker inside, make an inactive part\n              // The binding won't work, but subsequent bindings will\n              // TODO (justinfagnani): consider whether it's even worth it to\n              // make bindings in comments work\n              this.parts.push({type: 'node', index: -1});\n            }\n          }\n        }\n      }\n    };\n    _prepareTemplate(element);\n    // Remove text binding nodes after the walk to not disturb the TreeWalker\n    for (const n of nodesToRemove) {\n      n.parentNode!.removeChild(n);\n    }\n  }\n}\n\n/**\n * A placeholder for a dynamic expression in an HTML template.\n *\n * There are two built-in part types: AttributePart and NodePart. NodeParts\n * always represent a single dynamic expression, while AttributeParts may\n * represent as many expressions are contained in the attribute.\n *\n * A Template's parts are mutable, so parts can be replaced or modified\n * (possibly to implement different template semantics). The contract is that\n * parts can only be replaced, not removed, added or reordered, and parts must\n * always consume the correct number of values in their `update()` method.\n *\n * TODO(justinfagnani): That requirement is a little fragile. A\n * TemplateInstance could instead be more careful about which values it gives\n * to Part.update().\n */\nexport type TemplatePart = {\n  type: 'node',\n  index: number\n}|{type: 'attribute', index: number, name: string, strings: string[]};\n\nexport const isTemplatePartActive = (part: TemplatePart) => part.index !== -1;\n\n// Allows `document.createComment('')` to be renamed for a\n// small manual size-savings.\nexport const createMarker = () => document.createComment('');\n\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#attributes-0\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-character\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nexport const lastAttributeNameRegex =\n    /([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \\x09\\x0a\\x0c\\x0d\"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {isCEPolyfill} from './dom.js';\nimport {Part} from './part.js';\nimport {RenderOptions} from './render-options.js';\nimport {TemplateProcessor} from './template-processor.js';\nimport {isTemplatePartActive, Template} from './template.js';\n\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n  _parts: Array<Part|undefined> = [];\n  processor: TemplateProcessor;\n  options: RenderOptions;\n  template: Template;\n\n  constructor(\n      template: Template, processor: TemplateProcessor,\n      options: RenderOptions) {\n    this.template = template;\n    this.processor = processor;\n    this.options = options;\n  }\n\n  update(values: unknown[]) {\n    let i = 0;\n    for (const part of this._parts) {\n      if (part !== undefined) {\n        part.setValue(values[i]);\n      }\n      i++;\n    }\n    for (const part of this._parts) {\n      if (part !== undefined) {\n        part.commit();\n      }\n    }\n  }\n\n  _clone(): DocumentFragment {\n    // When using the Custom Elements polyfill, clone the node, rather than\n    // importing it, to keep the fragment in the template's document. This\n    // leaves the fragment inert so custom elements won't upgrade and\n    // potentially modify their contents by creating a polyfilled ShadowRoot\n    // while we traverse the tree.\n    const fragment = isCEPolyfill ?\n        this.template.element.content.cloneNode(true) as DocumentFragment :\n        document.importNode(this.template.element.content, true);\n\n    const parts = this.template.parts;\n    let partIndex = 0;\n    let nodeIndex = 0;\n    const _prepareInstance = (fragment: DocumentFragment) => {\n      // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n      // null\n      const walker = document.createTreeWalker(\n          fragment,\n          133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,\n          null,\n          false);\n      let node = walker.nextNode();\n      // Loop through all the nodes and parts of a template\n      while (partIndex < parts.length && node !== null) {\n        const part = parts[partIndex];\n        // Consecutive Parts may have the same node index, in the case of\n        // multiple bound attributes on an element. So each iteration we either\n        // increment the nodeIndex, if we aren't on a node with a part, or the\n        // partIndex if we are. By not incrementing the nodeIndex when we find a\n        // part, we allow for the next part to be associated with the current\n        // node if neccessasry.\n        if (!isTemplatePartActive(part)) {\n          this._parts.push(undefined);\n          partIndex++;\n        } else if (nodeIndex === part.index) {\n          if (part.type === 'node') {\n            const part = this.processor.handleTextExpression(this.options);\n            part.insertAfterNode(node.previousSibling!);\n            this._parts.push(part);\n          } else {\n            this._parts.push(...this.processor.handleAttributeExpressions(\n                node as Element, part.name, part.strings, this.options));\n          }\n          partIndex++;\n        } else {\n          nodeIndex++;\n          if (node.nodeName === 'TEMPLATE') {\n            _prepareInstance((node as HTMLTemplateElement).content);\n          }\n          node = walker.nextNode();\n        }\n      }\n    };\n    _prepareInstance(fragment);\n    if (isCEPolyfill) {\n      document.adoptNode(fragment);\n      customElements.upgrade(fragment);\n    }\n    return fragment;\n  }\n}\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {reparentNodes} from './dom.js';\nimport {TemplateProcessor} from './template-processor.js';\nimport {boundAttributeSuffix, lastAttributeNameRegex, marker, nodeMarker} from './template.js';\n\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n  strings: TemplateStringsArray;\n  values: unknown[];\n  type: string;\n  processor: TemplateProcessor;\n\n  constructor(\n      strings: TemplateStringsArray, values: unknown[], type: string,\n      processor: TemplateProcessor) {\n    this.strings = strings;\n    this.values = values;\n    this.type = type;\n    this.processor = processor;\n  }\n\n  /**\n   * Returns a string of HTML used to create a `<template>` element.\n   */\n  getHTML(): string {\n    const endIndex = this.strings.length - 1;\n    let html = '';\n    for (let i = 0; i < endIndex; i++) {\n      const s = this.strings[i];\n      // This exec() call does two things:\n      // 1) Appends a suffix to the bound attribute name to opt out of special\n      // attribute value parsing that IE11 and Edge do, like for style and\n      // many SVG attributes. The Template class also appends the same suffix\n      // when looking up attributes to create Parts.\n      // 2) Adds an unquoted-attribute-safe marker for the first expression in\n      // an attribute. Subsequent attribute expressions will use node markers,\n      // and this is safe since attributes with multiple expressions are\n      // guaranteed to be quoted.\n      const match = lastAttributeNameRegex.exec(s);\n      if (match) {\n        // We're starting a new bound attribute.\n        // Add the safe attribute suffix, and use unquoted-attribute-safe\n        // marker.\n        html += s.substr(0, match.index) + match[1] + match[2] +\n            boundAttributeSuffix + match[3] + marker;\n      } else {\n        // We're either in a bound node, or trailing bound attribute.\n        // Either way, nodeMarker is safe to use.\n        html += s + nodeMarker;\n      }\n    }\n    return html + this.strings[endIndex];\n  }\n\n  getTemplateElement(): HTMLTemplateElement {\n    const template = document.createElement('template');\n    template.innerHTML = this.getHTML();\n    return template;\n  }\n}\n\n/**\n * A TemplateResult for SVG fragments.\n *\n * This class wraps HTMl in an `<svg>` tag in order to parse its contents in the\n * SVG namespace, then modifies the template to remove the `<svg>` tag so that\n * clones only container the original fragment.\n */\nexport class SVGTemplateResult extends TemplateResult {\n  getHTML(): string {\n    return `<svg>${super.getHTML()}</svg>`;\n  }\n\n  getTemplateElement(): HTMLTemplateElement {\n    const template = super.getTemplateElement();\n    const content = template.content;\n    const svgElement = content.firstChild!;\n    content.removeChild(svgElement);\n    reparentNodes(content, svgElement.firstChild);\n    return template;\n  }\n}\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {isDirective} from './directive.js';\nimport {removeNodes} from './dom.js';\nimport {noChange, nothing, Part} from './part.js';\nimport {RenderOptions} from './render-options.js';\nimport {TemplateInstance} from './template-instance.js';\nimport {TemplateResult} from './template-result.js';\nimport {createMarker} from './template.js';\n\n// https://tc39.github.io/ecma262/#sec-typeof-operator\nexport type Primitive = null|undefined|boolean|number|string|Symbol|bigint;\nexport const isPrimitive = (value: unknown): value is Primitive => {\n  return (\n      value === null ||\n      !(typeof value === 'object' || typeof value === 'function'));\n};\n\n/**\n * Sets attribute values for AttributeParts, so that the value is only set once\n * even if there are multiple parts for an attribute.\n */\nexport class AttributeCommitter {\n  element: Element;\n  name: string;\n  strings: string[];\n  parts: AttributePart[];\n  dirty = true;\n\n  constructor(element: Element, name: string, strings: string[]) {\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n    this.parts = [];\n    for (let i = 0; i < strings.length - 1; i++) {\n      this.parts[i] = this._createPart();\n    }\n  }\n\n  /**\n   * Creates a single part. Override this to create a differnt type of part.\n   */\n  protected _createPart(): AttributePart {\n    return new AttributePart(this);\n  }\n\n  protected _getValue(): unknown {\n    const strings = this.strings;\n    const l = strings.length - 1;\n    let text = '';\n\n    for (let i = 0; i < l; i++) {\n      text += strings[i];\n      const part = this.parts[i];\n      if (part !== undefined) {\n        const v = part.value;\n        if (v != null &&\n            (Array.isArray(v) ||\n             // tslint:disable-next-line:no-any\n             typeof v !== 'string' && (v as any)[Symbol.iterator])) {\n          for (const t of v as Iterable<unknown>) {\n            text += typeof t === 'string' ? t : String(t);\n          }\n        } else {\n          text += typeof v === 'string' ? v : String(v);\n        }\n      }\n    }\n\n    text += strings[l];\n    return text;\n  }\n\n  commit(): void {\n    if (this.dirty) {\n      this.dirty = false;\n      this.element.setAttribute(this.name, this._getValue() as string);\n    }\n  }\n}\n\nexport class AttributePart implements Part {\n  committer: AttributeCommitter;\n  value: unknown = undefined;\n\n  constructor(comitter: AttributeCommitter) {\n    this.committer = comitter;\n  }\n\n  setValue(value: unknown): void {\n    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n      this.value = value;\n      // If the value is a not a directive, dirty the committer so that it'll\n      // call setAttribute. If the value is a directive, it'll dirty the\n      // committer if it calls setValue().\n      if (!isDirective(value)) {\n        this.committer.dirty = true;\n      }\n    }\n  }\n\n  commit() {\n    while (isDirective(this.value)) {\n      const directive = this.value;\n      this.value = noChange;\n      directive(this);\n    }\n    if (this.value === noChange) {\n      return;\n    }\n    this.committer.commit();\n  }\n}\n\nexport class NodePart implements Part {\n  options: RenderOptions;\n  startNode!: Node;\n  endNode!: Node;\n  value: unknown = undefined;\n  _pendingValue: unknown = undefined;\n\n  constructor(options: RenderOptions) {\n    this.options = options;\n  }\n\n  /**\n   * Inserts this part into a container.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  appendInto(container: Node) {\n    this.startNode = container.appendChild(createMarker());\n    this.endNode = container.appendChild(createMarker());\n  }\n\n  /**\n   * Inserts this part between `ref` and `ref`'s next sibling. Both `ref` and\n   * its next sibling must be static, unchanging nodes such as those that appear\n   * in a literal section of a template.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  insertAfterNode(ref: Node) {\n    this.startNode = ref;\n    this.endNode = ref.nextSibling!;\n  }\n\n  /**\n   * Appends this part into a parent part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  appendIntoPart(part: NodePart) {\n    part._insert(this.startNode = createMarker());\n    part._insert(this.endNode = createMarker());\n  }\n\n  /**\n   * Appends this part after `ref`\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  insertAfterPart(ref: NodePart) {\n    ref._insert(this.startNode = createMarker());\n    this.endNode = ref.endNode;\n    ref.endNode = this.startNode;\n  }\n\n  setValue(value: unknown): void {\n    this._pendingValue = value;\n  }\n\n  commit() {\n    while (isDirective(this._pendingValue)) {\n      const directive = this._pendingValue;\n      this._pendingValue = noChange;\n      directive(this);\n    }\n    const value = this._pendingValue;\n    if (value === noChange) {\n      return;\n    }\n    if (isPrimitive(value)) {\n      if (value !== this.value) {\n        this._commitText(value);\n      }\n    } else if (value instanceof TemplateResult) {\n      this._commitTemplateResult(value);\n    } else if (value instanceof Node) {\n      this._commitNode(value);\n    } else if (\n        Array.isArray(value) ||\n        // tslint:disable-next-line:no-any\n        (value as any)[Symbol.iterator]) {\n      this._commitIterable(value as Iterable<unknown>);\n    } else if (value === nothing) {\n      this.value = nothing;\n      this.clear();\n    } else {\n      // Fallback, will render the string representation\n      this._commitText(value);\n    }\n  }\n\n  private _insert(node: Node) {\n    this.endNode.parentNode!.insertBefore(node, this.endNode);\n  }\n\n  private _commitNode(value: Node): void {\n    if (this.value === value) {\n      return;\n    }\n    this.clear();\n    this._insert(value);\n    this.value = value;\n  }\n\n  private _commitText(value: unknown): void {\n    const node = this.startNode.nextSibling!;\n    value = value == null ? '' : value;\n    if (node === this.endNode.previousSibling &&\n        node.nodeType === 3 /* Node.TEXT_NODE */) {\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      // TODO(justinfagnani): Can we just check if this.value is primitive?\n      (node as Text).data = value as string;\n    } else {\n      this._commitNode(document.createTextNode(\n          typeof value === 'string' ? value : String(value)));\n    }\n    this.value = value;\n  }\n\n  private _commitTemplateResult(value: TemplateResult): void {\n    const template = this.options.templateFactory(value);\n    if (this.value instanceof TemplateInstance &&\n        this.value.template === template) {\n      this.value.update(value.values);\n    } else {\n      // Make sure we propagate the template processor from the TemplateResult\n      // so that we use its syntax extension, etc. The template factory comes\n      // from the render function options so that it can control template\n      // caching and preprocessing.\n      const instance =\n          new TemplateInstance(template, value.processor, this.options);\n      const fragment = instance._clone();\n      instance.update(value.values);\n      this._commitNode(fragment);\n      this.value = instance;\n    }\n  }\n\n  private _commitIterable(value: Iterable<unknown>): void {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\n    // If _value is an array, then the previous render was of an\n    // iterable and _value will contain the NodeParts from the previous\n    // render. If _value is not an array, clear this part and make a new\n    // array for NodeParts.\n    if (!Array.isArray(this.value)) {\n      this.value = [];\n      this.clear();\n    }\n\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this.value as NodePart[];\n    let partIndex = 0;\n    let itemPart: NodePart|undefined;\n\n    for (const item of value) {\n      // Try to reuse an existing part\n      itemPart = itemParts[partIndex];\n\n      // If no existing part, create a new one\n      if (itemPart === undefined) {\n        itemPart = new NodePart(this.options);\n        itemParts.push(itemPart);\n        if (partIndex === 0) {\n          itemPart.appendIntoPart(this);\n        } else {\n          itemPart.insertAfterPart(itemParts[partIndex - 1]);\n        }\n      }\n      itemPart.setValue(item);\n      itemPart.commit();\n      partIndex++;\n    }\n\n    if (partIndex < itemParts.length) {\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n      this.clear(itemPart && itemPart!.endNode);\n    }\n  }\n\n  clear(startNode: Node = this.startNode) {\n    removeNodes(\n        this.startNode.parentNode!, startNode.nextSibling!, this.endNode);\n  }\n}\n\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nexport class BooleanAttributePart implements Part {\n  element: Element;\n  name: string;\n  strings: string[];\n  value: unknown = undefined;\n  _pendingValue: unknown = undefined;\n\n  constructor(element: Element, name: string, strings: string[]) {\n    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n      throw new Error(\n          'Boolean attributes can only contain a single expression');\n    }\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n  }\n\n  setValue(value: unknown): void {\n    this._pendingValue = value;\n  }\n\n  commit() {\n    while (isDirective(this._pendingValue)) {\n      const directive = this._pendingValue;\n      this._pendingValue = noChange;\n      directive(this);\n    }\n    if (this._pendingValue === noChange) {\n      return;\n    }\n    const value = !!this._pendingValue;\n    if (this.value !== value) {\n      if (value) {\n        this.element.setAttribute(this.name, '');\n      } else {\n        this.element.removeAttribute(this.name);\n      }\n    }\n    this.value = value;\n    this._pendingValue = noChange;\n  }\n}\n\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nexport class PropertyCommitter extends AttributeCommitter {\n  single: boolean;\n\n  constructor(element: Element, name: string, strings: string[]) {\n    super(element, name, strings);\n    this.single =\n        (strings.length === 2 && strings[0] === '' && strings[1] === '');\n  }\n\n  protected _createPart(): PropertyPart {\n    return new PropertyPart(this);\n  }\n\n  _getValue() {\n    if (this.single) {\n      return this.parts[0].value;\n    }\n    return super._getValue();\n  }\n\n  commit(): void {\n    if (this.dirty) {\n      this.dirty = false;\n      // tslint:disable-next-line:no-any\n      (this.element as any)[this.name] = this._getValue();\n    }\n  }\n}\n\nexport class PropertyPart extends AttributePart {}\n\n// Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the thrid\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\nlet eventOptionsSupported = false;\n\ntry {\n  const options = {\n    get capture() {\n      eventOptionsSupported = true;\n      return false;\n    }\n  };\n  // tslint:disable-next-line:no-any\n  window.addEventListener('test', options as any, options);\n  // tslint:disable-next-line:no-any\n  window.removeEventListener('test', options as any, options);\n} catch (_e) {\n}\n\n\ntype EventHandlerWithOptions =\n    EventListenerOrEventListenerObject&Partial<AddEventListenerOptions>;\nexport class EventPart implements Part {\n  element: Element;\n  eventName: string;\n  eventContext?: EventTarget;\n  value: undefined|EventHandlerWithOptions = undefined;\n  _options?: AddEventListenerOptions;\n  _pendingValue: undefined|EventHandlerWithOptions = undefined;\n  _boundHandleEvent: (event: Event) => void;\n\n  constructor(element: Element, eventName: string, eventContext?: EventTarget) {\n    this.element = element;\n    this.eventName = eventName;\n    this.eventContext = eventContext;\n    this._boundHandleEvent = (e) => this.handleEvent(e);\n  }\n\n  setValue(value: undefined|EventHandlerWithOptions): void {\n    this._pendingValue = value;\n  }\n\n  commit() {\n    while (isDirective(this._pendingValue)) {\n      const directive = this._pendingValue;\n      this._pendingValue = noChange as EventHandlerWithOptions;\n      directive(this);\n    }\n    if (this._pendingValue === noChange) {\n      return;\n    }\n\n    const newListener = this._pendingValue;\n    const oldListener = this.value;\n    const shouldRemoveListener = newListener == null ||\n        oldListener != null &&\n            (newListener.capture !== oldListener.capture ||\n             newListener.once !== oldListener.once ||\n             newListener.passive !== oldListener.passive);\n    const shouldAddListener =\n        newListener != null && (oldListener == null || shouldRemoveListener);\n\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(\n          this.eventName, this._boundHandleEvent, this._options);\n    }\n    if (shouldAddListener) {\n      this._options = getOptions(newListener);\n      this.element.addEventListener(\n          this.eventName, this._boundHandleEvent, this._options);\n    }\n    this.value = newListener;\n    this._pendingValue = noChange as EventHandlerWithOptions;\n  }\n\n  handleEvent(event: Event) {\n    if (typeof this.value === 'function') {\n      this.value.call(this.eventContext || this.element, event);\n    } else {\n      (this.value as EventListenerObject).handleEvent(event);\n    }\n  }\n}\n\n// We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\nconst getOptions = (o: AddEventListenerOptions|undefined) => o &&\n    (eventOptionsSupported ?\n         {capture: o.capture, passive: o.passive, once: o.once} :\n         o.capture as AddEventListenerOptions);\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {Part} from './part.js';\nimport {AttributeCommitter, BooleanAttributePart, EventPart, NodePart, PropertyCommitter} from './parts.js';\nimport {RenderOptions} from './render-options.js';\nimport {TemplateProcessor} from './template-processor.js';\n\n/**\n * Creates Parts when a template is instantiated.\n */\nexport class DefaultTemplateProcessor implements TemplateProcessor {\n  /**\n   * Create parts for an attribute-position binding, given the event, attribute\n   * name, and string literals.\n   *\n   * @param element The element containing the binding\n   * @param name  The attribute name\n   * @param strings The string literals. There are always at least two strings,\n   *   event for fully-controlled bindings with a single expression.\n   */\n  handleAttributeExpressions(\n      element: Element, name: string, strings: string[],\n      options: RenderOptions): Part[] {\n    const prefix = name[0];\n    if (prefix === '.') {\n      const comitter = new PropertyCommitter(element, name.slice(1), strings);\n      return comitter.parts;\n    }\n    if (prefix === '@') {\n      return [new EventPart(element, name.slice(1), options.eventContext)];\n    }\n    if (prefix === '?') {\n      return [new BooleanAttributePart(element, name.slice(1), strings)];\n    }\n    const comitter = new AttributeCommitter(element, name, strings);\n    return comitter.parts;\n  }\n  /**\n   * Create parts for a text-position binding.\n   * @param templateFactory\n   */\n  handleTextExpression(options: RenderOptions) {\n    return new NodePart(options);\n  }\n}\n\nexport const defaultTemplateProcessor = new DefaultTemplateProcessor();\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {TemplateResult} from './template-result.js';\nimport {marker, Template} from './template.js';\n\n/**\n * A function type that creates a Template from a TemplateResult.\n *\n * This is a hook into the template-creation process for rendering that\n * requires some modification of templates before they're used, like ShadyCSS,\n * which must add classes to elements and remove styles.\n *\n * Templates should be cached as aggressively as possible, so that many\n * TemplateResults produced from the same expression only do the work of\n * creating the Template the first time.\n *\n * Templates are usually cached by TemplateResult.strings and\n * TemplateResult.type, but may be cached by other keys if this function\n * modifies the template.\n *\n * Note that currently TemplateFactories must not add, remove, or reorder\n * expressions, because there is no way to describe such a modification\n * to render() so that values are interpolated to the correct place in the\n * template instances.\n */\nexport type TemplateFactory = (result: TemplateResult) => Template;\n\n/**\n * The default TemplateFactory which caches Templates keyed on\n * result.type and result.strings.\n */\nexport function templateFactory(result: TemplateResult) {\n  let templateCache = templateCaches.get(result.type);\n  if (templateCache === undefined) {\n    templateCache = {\n      stringsArray: new WeakMap<TemplateStringsArray, Template>(),\n      keyString: new Map<string, Template>()\n    };\n    templateCaches.set(result.type, templateCache);\n  }\n\n  let template = templateCache.stringsArray.get(result.strings);\n  if (template !== undefined) {\n    return template;\n  }\n\n  // If the TemplateStringsArray is new, generate a key from the strings\n  // This key is shared between all templates with identical content\n  const key = result.strings.join(marker);\n\n  // Check if we already have a Template for this key\n  template = templateCache.keyString.get(key);\n  if (template === undefined) {\n    // If we have not seen this key before, create a new Template\n    template = new Template(result, result.getTemplateElement());\n    // Cache the Template for this key\n    templateCache.keyString.set(key, template);\n  }\n\n  // Cache all future queries for this TemplateStringsArray\n  templateCache.stringsArray.set(result.strings, template);\n  return template;\n}\n\n/**\n * The first argument to JS template tags retain identity across multiple\n * calls to a tag for the same literal, so we can cache work done per literal\n * in a Map.\n *\n * Safari currently has a bug which occasionally breaks this behaviour, so we\n * need to cache the Template at two levels. We first cache the\n * TemplateStringsArray, and if that fails, we cache a key constructed by\n * joining the strings array.\n */\nexport type templateCache = {\n  stringsArray: WeakMap<TemplateStringsArray, Template>;\n  keyString: Map<string, Template>;\n};\n\nexport const templateCaches = new Map<string, templateCache>();\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {removeNodes} from './dom.js';\nimport {NodePart} from './parts.js';\nimport {RenderOptions} from './render-options.js';\nimport {templateFactory} from './template-factory.js';\nimport {TemplateResult} from './template-result.js';\n\nexport const parts = new WeakMap<Node, NodePart>();\n\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result a TemplateResult created by evaluating a template tag like\n *     `html` or `svg`.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param options RenderOptions for the entire render tree rendered to this\n *     container. Render options must *not* change between renders to the same\n *     container, as those changes will not effect previously rendered DOM.\n */\nexport const render =\n    (result: TemplateResult,\n     container: Element|DocumentFragment,\n     options?: Partial<RenderOptions>) => {\n      let part = parts.get(container);\n      if (part === undefined) {\n        removeNodes(container, container.firstChild);\n        parts.set(container, part = new NodePart({\n                               templateFactory,\n                               ...options,\n                             }));\n        part.appendInto(container);\n      }\n      part.setValue(result);\n      part.commit();\n    };\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n *\n * Main lit-html module.\n *\n * Main exports:\n *\n * -  [[html]]\n * -  [[svg]]\n * -  [[render]]\n *\n * @module lit-html\n * @preferred\n */\n\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\nimport {defaultTemplateProcessor} from './lib/default-template-processor.js';\nimport {SVGTemplateResult, TemplateResult} from './lib/template-result.js';\n\nexport {DefaultTemplateProcessor, defaultTemplateProcessor} from './lib/default-template-processor.js';\nexport {directive, DirectiveFn, isDirective} from './lib/directive.js';\n// TODO(justinfagnani): remove line when we get NodePart moving methods\nexport {removeNodes, reparentNodes} from './lib/dom.js';\nexport {noChange, nothing, Part} from './lib/part.js';\nexport {AttributeCommitter, AttributePart, BooleanAttributePart, EventPart, isPrimitive, NodePart, PropertyCommitter, PropertyPart} from './lib/parts.js';\nexport {RenderOptions} from './lib/render-options.js';\nexport {parts, render} from './lib/render.js';\nexport {templateCaches, templateFactory} from './lib/template-factory.js';\nexport {TemplateInstance} from './lib/template-instance.js';\nexport {TemplateProcessor} from './lib/template-processor.js';\nexport {SVGTemplateResult, TemplateResult} from './lib/template-result.js';\nexport {createMarker, isTemplatePartActive, Template} from './lib/template.js';\n\ndeclare global {\n  interface Window {\n    litHtmlVersions: string[];\n  }\n}\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n(window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.0.0');\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings: TemplateStringsArray, ...values: unknown[]) =>\n    new TemplateResult(strings, values, 'html', defaultTemplateProcessor);\n\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings: TemplateStringsArray, ...values: unknown[]) =>\n    new SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);\n","import { Frame } from \"./Frame\";\nimport { Instruction } from \"./input\";\n\nexport interface Constant {\n  index: number;\n  type: string;\n  value: string;\n}\n\nexport enum Type {\n  Ref,\n  Constant,\n  // Numeric\n  Int,\n  Long,\n  Float,\n  Double,\n  Char,\n  Short\n}\n\nexport function typePrefix(type: Type): string {\n  switch (type) {\n    case Type.Int:\n      return \"i\";\n    case Type.Long:\n      return \"l\";\n    case Type.Float:\n      return \"f\";\n    case Type.Double:\n      return \"d\";\n    case Type.Char:\n      return \"c\";\n    case Type.Short:\n      return \"s\";\n    default:\n      throw new Error(`Unexpected type ${type}`);\n  }\n}\n\nexport interface Instruction {\n  type?: Type;\n  code: string;\n  apply: (frame: Frame) => void;\n}\n\nexport interface InstructionInstance {\n  position: number;\n  instruction: Instruction;\n  args: any[];\n}\n\nexport interface InstructionBuilder {\n  [index: string]: (args: any[]) => Instruction;\n}\n\nexport interface MethodBody {\n  stack: number;\n  locals: number;\n  args_size: number;\n  code: InstructionInstance[];\n}\n","import { Frames } from \"./Frames\";\nimport { InstructionInstance, MethodBody, Type } from \"./input\";\nimport { LocalVariables } from \"./LocalVariables\";\nimport { OperandStack } from \"./OperandStack\";\nimport { Value } from \"./runtime\";\n\nexport class Frame {\n  get currentInstruction(): InstructionInstance {\n    return this.getInstruction(this.position);\n  }\n\n  constructor(\n    readonly parent: Frames,\n    readonly name: string,\n    public position: number,\n    readonly args: Value[],\n    readonly methodBody: MethodBody,\n    readonly stack: OperandStack,\n    readonly locals: LocalVariables\n  ) {}\n\n  public next(position?: number): void {\n    if (position) {\n      this.getInstruction(position);\n      this.position = position;\n    } else {\n      const idx = this.methodBody.code.indexOf(this.currentInstruction);\n      this.position = this.methodBody.code[idx + 1].position;\n    }\n  }\n\n  public return(value?: Value): void {\n    if (value) {\n      console.log(\n        `${this.name}(${this.args}) return: [${Type[value.type]}] ${\n          value.value\n        }`\n      );\n    } else {\n      console.log(`${this.name}(${this.args}) return: void`);\n    }\n    this.parent.endFrame(value);\n  }\n\n  private getInstruction(pos: number): InstructionInstance {\n    const res = this.methodBody.code.find(inst => inst.position === pos);\n    if (!res) {\n      throw new Error(`No instruction found with position ${pos}`);\n    }\n    return res;\n  }\n}\n","import { Value } from \"./runtime\";\n\nexport class LocalVariables {\n  private _list: Value[] = [];\n  get list(): Value[] {\n    return this._list;\n  }\n\n  constructor(size: number) {\n    this._list = Array.apply(null, Array<Value>(size));\n  }\n\n  public get(i: number): Value {\n    return this._list[i];\n  }\n\n  public set(i: number, value: Value): void {\n    this._list[i] = value;\n  }\n}\n","import { Type } from \"./input\";\nimport { NativeMethod } from \"./native-methods\";\nimport { Value } from \"./runtime\";\n\nexport interface NativeMethod {\n  args_size: number;\n\n  call(args: any[]): Value | undefined;\n}\n\nfunction printConsole() {\n  const args = Array.from(arguments);\n  console.log(...args);\n  return;\n}\n\nconst println: NativeMethod = {\n  args_size: 1,\n  call(args: any[]) {\n    // first arg is the java/io/PrintStream\n    const value = args[1];\n    if (value.type && value.value) {\n      alert(`[${Type[value.type]}]: ${value.value}`);\n    } else {\n      alert(JSON.stringify(value));\n    }\n    return undefined;\n  }\n};\n\nexport const nativeMethods = new Map<string, NativeMethod>()\n  .set(\"Method java/io/PrintStream.println:(I)V\", println)\n  .set(\"Method java/io/PrintStream.println:(Ljava/lang/Object;)V\", println);\n","import { Value } from \"./runtime\";\n\ntype MaybeValue = Value | null;\n\nexport class OperandStack {\n  private _list: MaybeValue[];\n  private _position = 0;\n\n  get list(): MaybeValue[] {\n    return this._list;\n  }\n\n  constructor(size: number) {\n    this._list = Array.apply(null, Array<MaybeValue>(size));\n  }\n\n  public push(value: Value): void {\n    this._list[this._position] = value;\n    this._position++;\n  }\n\n  public pop(): Value {\n    const v = this._list[this._position - 1];\n    this._list[this._position - 1] = null;\n    this._position--;\n    return v as Value;\n  }\n\n  public peek(): Value {\n    const v = this._list[this._position - 1];\n    return v as Value;\n  }\n}\n","import { Frame } from \"./Frame\";\nimport { Constant, MethodBody, Type } from \"./input\";\nimport { LocalVariables } from \"./LocalVariables\";\nimport { nativeMethods } from \"./native-methods\";\nimport { OperandStack } from \"./OperandStack\";\nimport { Value } from \"./runtime\";\n\nexport class Frames {\n  public readonly frames: Frame[] = [];\n\n  get currentFrame(): Frame {\n    return this.frames[this.frames.length - 1];\n  }\n\n  constructor(\n    readonly constantPool: string,\n    readonly methods: Map<string, MethodBody>,\n    mainArgs: Value[] = [{ type: Type.Ref, value: [] }]\n  ) {\n    const mainMethod = methods.get(\"main\");\n    if (!mainMethod) {\n      throw new Error(`'main' method is missing`);\n    }\n    const mainFrame = this.createFrame(\"main\", mainMethod, mainArgs);\n    mainFrame.locals.set(0, mainArgs[0]);\n    this.frames.push(mainFrame);\n  }\n\n  // const btn = document.querySelector<HTMLButtonElement>(\".frames menu .next\" );\n  //     if (btn) {\n  //       btn.onclick = () => {\n  //         frames.next();\n  //         catnip(elt);\n  //       };\n  //     }\n\n  public next() {\n    const currentFrame = this.currentFrame;\n    const instruction = currentFrame.currentInstruction;\n    instruction.instruction.apply(currentFrame);\n  }\n\n  public callStaticMethod(value: string): void {\n    const nativeMethod = nativeMethods.get(value);\n    if (nativeMethod) {\n      const args = this.getArgs(nativeMethod.args_size);\n      const res = nativeMethod.call(args);\n      if (res) {\n        this.currentFrame.stack.push(res);\n      }\n      this.currentFrame.next();\n    } else {\n      const method = this.getMethod(value);\n      const args = this.getArgs(method.args_size);\n      const frame = this.createFrame(value, method, args);\n      this.frames.push(frame);\n      // bind args to locals\n      const locals = this.currentFrame.locals;\n      args.forEach((arg, index) => locals.set(index, arg));\n    }\n  }\n\n  public callObjectMethod(value: any): void {\n    const nativeMethod = nativeMethods.get(value);\n    if (nativeMethod) {\n      const methodArgs = this.getArgs(nativeMethod.args_size);\n      const objectRef = this.currentFrame.stack.pop();\n      const args = [objectRef, ...methodArgs];\n      const res = nativeMethod.call(args);\n      if (res) {\n        this.currentFrame.stack.push(res);\n      }\n      this.currentFrame.next();\n    } else {\n      const method = this.getMethod(value);\n      const methodArgs = this.getArgs(method.args_size);\n      const objectRef = this.currentFrame.stack.pop();\n      const args = [objectRef, ...methodArgs];\n      const frame = this.createFrame(value, method, args);\n      this.frames.push(frame);\n      // bind args to locals\n      const locals = this.currentFrame.locals;\n      args.forEach((arg, index) => locals.set(index, arg));\n    }\n  }\n\n  public endFrame(value?: Value): void {\n    this.frames.pop();\n    if (value) {\n      this.currentFrame.stack.push(value);\n    }\n    if (this.frames.length === 0) {\n      alert(\"Done\");\n    } else {\n      this.currentFrame.next();\n    }\n  }\n\n  private createFrame(name: string, body: MethodBody, args: Value[]): Frame {\n    return new Frame(\n      this,\n      name,\n      body.code[0].position,\n      args,\n      body,\n      new OperandStack(body.stack),\n      new LocalVariables(body.locals)\n    );\n  }\n\n  private getMethod(m: string): MethodBody {\n    const method = this.methods.get(m);\n    if (!method) {\n      throw new Error(\n        `'${m}' not found, got ${Array.from(this.methods.keys())}`\n      );\n    }\n    return method;\n  }\n\n  private getArgs(size: number): Value[] {\n    const args: Value[] = [];\n    for (let i = 0; i < size; i++) {\n      args.push(this.currentFrame.stack.pop());\n    }\n    return args;\n  }\n}\n","import { Constant } from \"../../models/input\";\nimport { ConstantPoolParser } from \"../parser\";\n\nconst createConstant = (s: string): Constant => {\n  const regexpConstant = /^\\s*#(\\d+) = ([a-zA-Z0-8]*)\\s+(\\S*)(\\s+\\/\\/\\s(.*))?$/gm;\n  const t = regexpConstant.exec(s);\n  const [all, sIndex, type, v0, rest, v1] = Array.from(t || []);\n  const index = parseInt(sIndex, 10);\n  const value = v1 ? v1 : v0;\n  return { index, type, value };\n};\n\nexport const constantPoolParser: ConstantPoolParser = {\n  parse(input: string): Constant[] {\n    return input\n      .split(\"\\n\")\n      .map(s => s.trim())\n      .filter(s => s !== \"\")\n      .map(s => createConstant(s));\n  }\n};\n","import { Frame } from \"../Frame\";\nimport { Instruction, InstructionBuilder, Type, typePrefix } from \"../input\";\n\n// return, ireturn\n\nexport const flowInstructions: InstructionBuilder = {};\n\ninterface Comparators {\n  [index: string]: (a: number, b: number) => boolean;\n}\n\nconst comparators: Comparators = {\n  ge: (a: number, b: number): boolean => a >= b,\n  gt: (a: number, b: number): boolean => a > b,\n  le: (a: number, b: number): boolean => a <= b,\n  lt: (a: number, b: number): boolean => a < b,\n  ne: (a: number, b: number): boolean => a !== b\n};\n\nconst typedIfCmp = (\n  type: Type,\n  jump: number,\n  cmp: keyof Comparators\n): Instruction => ({\n  type,\n  code: `if_${typePrefix(type)}cmp${cmp}`,\n  apply: (frame: Frame) => {\n    const b = frame.stack.pop().value as number;\n    const a = frame.stack.pop().value as number;\n    const needJump = comparators[cmp](a, b);\n    frame.next(needJump ? jump : undefined);\n  }\n});\n\nconst gotoLabel = (jump: number): Instruction => ({\n  code: `goto`,\n  apply: (frame: Frame) => {\n    frame.next(jump);\n  }\n});\n\nflowInstructions.goto = (args: any[]) => {\n  const jump = parseInt(args[0], 10);\n  return gotoLabel(jump);\n};\n\nflowInstructions.return = () => ({\n  code: `return`,\n  apply: (frame: Frame) => frame.return()\n});\n\n[Type.Int, Type.Long, Type.Float, Type.Double].forEach(type => {\n  const t = typePrefix(type);\n\n  [\"gt\", \"ge\", \"lt\", \"le\", \"ne\"].forEach(cmp => {\n    flowInstructions[`if_${t}cmp${cmp}`] = (args: any[]) => {\n      const jump = parseInt(args[0], 10);\n      return typedIfCmp(type, jump, cmp);\n    };\n  });\n\n  flowInstructions[`${t}return`] = () => ({\n    type,\n    code: `${t}return`,\n    apply: (frame: Frame) => {\n      const value = frame.stack.pop();\n      frame.return(value);\n    }\n  });\n});\n","import { Frame } from \"../Frame\";\nimport { Instruction, InstructionBuilder, Type, typePrefix } from \"../input\";\n\n// imul, iinc\n\nexport const mathInstructions: InstructionBuilder = {};\n\nconst typedBinaryOperation = (\n  type: Type,\n  key: string,\n  ope: (a: number, b: number) => number\n): Instruction => ({\n  type,\n  code: typePrefix(type) + key,\n  apply: (frame: Frame) => {\n    const a = frame.stack.pop();\n    const b = frame.stack.pop();\n    frame.stack.push({ type, value: ope(a.value, b.value) });\n    frame.next();\n  }\n});\n\nconst typedUnaryOperation = (\n  type: Type,\n  key: string,\n  ope: (a: number) => number\n): Instruction => ({\n  type,\n  code: typePrefix(type) + key,\n  apply: (frame: Frame) => {\n    const a = frame.stack.pop();\n    const b = frame.stack.pop();\n    frame.stack.push({ type, value: ope(a.value) });\n    frame.next();\n  }\n});\n\nconst incr = (index: number, increment: number): Instruction => ({\n  type: Type.Int,\n  code: \"iinc\",\n  apply: (frame: Frame) => {\n    const { type, value } = frame.locals.get(index);\n    frame.locals.set(index, { type, value: value + increment });\n    frame.next();\n  }\n});\n\n// Arithmetic\n[Type.Int, Type.Long, Type.Float, Type.Double].forEach(type => {\n  const t = typePrefix(type);\n\n  mathInstructions[`${t}add`] = () =>\n    typedBinaryOperation(type, \"add\", (a, b) => a + b);\n  mathInstructions[`${t}sub`] = () =>\n    typedBinaryOperation(type, \"sub\", (a, b) => a - b);\n  mathInstructions[`${t}mul`] = () =>\n    typedBinaryOperation(type, \"mul\", (a, b) => a * b);\n  mathInstructions[`${t}div`] = () =>\n    typedBinaryOperation(type, \"rem\", (a, b) => a % b);\n  mathInstructions[`${t}neg`] = () => typedUnaryOperation(type, \"neg\", a => -a);\n\n  mathInstructions.iinc = (args: any[]) => {\n    const index = parseInt(args[0], 10);\n    const increment = parseInt(args[1], 10);\n    return incr(index, increment);\n  };\n});\n","import { Frame } from \"../Frame\";\nimport { InstructionBuilder, Type } from \"../input\";\n\nexport const objectsInstructions: InstructionBuilder = {};\n\nobjectsInstructions.getstatic = (args: any[]) => ({\n  code: \"getstatic\",\n  apply: (frame: Frame) => {\n    const value = args[0];\n    frame.stack.push({ type: Type.Constant, value });\n    frame.next();\n  }\n});\n\nobjectsInstructions.invokestatic = (args: any[]) => ({\n  code: \"invokestatic\",\n  apply: (frame: Frame) => {\n    const value = args[0];\n    frame.parent.callStaticMethod(value);\n  }\n});\n\nobjectsInstructions.invokevirtual = (args: any[]) => ({\n  code: \"invokevirtual\",\n  apply: (frame: Frame) => {\n    const value = args[0];\n    frame.parent.callObjectMethod(value);\n  }\n});\n\n// new, invokespecial, putfield, getfield\n","import { Frame } from \"../Frame\";\nimport { Instruction, InstructionBuilder } from \"../input\";\n\n//\n\nexport const otherInstructions: InstructionBuilder = {};\n\notherInstructions.nop = (args: any[]): Instruction => ({\n  code: \"nop\",\n  apply: (frame: Frame) => frame.next()\n});\n","import { Frame } from \"../Frame\";\nimport { Instruction, InstructionBuilder, Type, typePrefix } from \"../input\";\n\nexport const stackInstructions: InstructionBuilder = {};\n\nconst typedConst = (type: Type, value: any): Instruction => ({\n  type,\n  code: `${typePrefix(type)}const_${value}`,\n  apply: (frame: Frame) => {\n    frame.stack.push({ type, value });\n    frame.next();\n  }\n});\n\nconst typedStore = (type: Type, index: number): Instruction => ({\n  type,\n  code: `${typePrefix(type)}store_${index}`,\n  apply: (frame: Frame) => {\n    const value = frame.stack.pop();\n    frame.locals.set(index, value);\n    frame.next();\n  }\n});\n\nconst typedLoad = (type: Type, index: number): Instruction => ({\n  type,\n  code: `${typePrefix(type)}load_${index}`,\n  apply: (frame: Frame) => {\n    const value = frame.locals.get(index);\n    frame.stack.push(value);\n    frame.next();\n  }\n});\n\n// Typed const, store, load\n[Type.Int, Type.Long, Type.Float, Type.Double].forEach(type => {\n  const t = typePrefix(type);\n\n  for (let i = 0; i < 6; i++) {\n    stackInstructions[`${t}const_${i}`] = () => typedConst(type, i);\n  }\n  for (let i = 0; i < 4; i++) {\n    stackInstructions[`${t}store_${i}`] = () => typedStore(type, i);\n    stackInstructions[`${t}load_${i}`] = () => typedLoad(type, i);\n  }\n});\n\nstackInstructions.iconst_m1 = () => typedConst(Type.Int, -1);\n\nstackInstructions.ldc = (args: any[]): Instruction => ({\n  code: \"ldc\",\n  apply: (frame: Frame) => {\n    const value = args[0];\n    frame.stack.push({ type: Type.Constant, value });\n    frame.next();\n  }\n});\n\nstackInstructions.dup = (args: any[]): Instruction => ({\n  code: \"dup\",\n  apply: (frame: Frame) => {\n    const value = frame.stack.peek();\n    frame.stack.push(value);\n    frame.next();\n  }\n});\n\n// Tstore, Tload, bipush, putstatic, aastore\n","import { Instruction, InstructionBuilder } from \"../input\";\nimport { flowInstructions } from \"./flow\";\nimport { mathInstructions } from \"./math\";\nimport { objectsInstructions } from \"./objects\";\nimport { otherInstructions } from \"./others\";\nimport { stackInstructions } from \"./stacks\";\n\nconst allInstructions: InstructionBuilder = {\n  ...stackInstructions,\n  ...objectsInstructions,\n  ...mathInstructions,\n  ...flowInstructions,\n  ...otherInstructions\n};\n\nconsole.log(`Got ${Object.keys(allInstructions).length} instructions`);\n\nexport const lookupInstruction = (\n  opscode: string,\n  args: any[]\n): Instruction => {\n  const i = allInstructions[opscode];\n  if (i) {\n    return i(args);\n  }\n\n  throw new Error(`Opscode ${opscode} not found !`);\n};\n","import { Constant, InstructionInstance, MethodBody } from \"../../models/input\";\nimport { lookupInstruction } from \"../../models/instructions\";\nimport { MethodParser } from \"../parser\";\n\nclass MethodBodyImpl implements MethodBody {\n  constructor(\n    readonly stack: number,\n    readonly locals: number,\n    readonly args_size: number,\n    readonly code: InstructionInstance[]\n  ) {}\n}\n\nconst createInstruction = (line: string): InstructionInstance => {\n  const regexpInstruction1 = /^\\s*(\\d+): ([a-z0-9_]*)\\s+(\\S*)\\s+\\/\\/\\s(.*)$/gm;\n  const t1 = regexpInstruction1.exec(line);\n  if (t1 !== null) {\n    const [all, sIndex, opscode, v0, v1] = Array.from(t1 || []);\n    const position = parseInt(sIndex, 10);\n    const args = v0 && v1 ? [v1] : v0 ? [v0] : [];\n    const instruction = lookupInstruction(opscode, args);\n    return { position, instruction, args };\n  }\n\n  const regexpInstruction2 = /^\\s*(\\d+): ([a-z0-9_]*)(\\s+([\\d, ]*))?$/gm;\n  const t2 = regexpInstruction2.exec(line);\n  if (t2 !== null) {\n    const [all, sIndex, opscode, v0, v1] = Array.from(t2 || []);\n    const position = parseInt(sIndex, 10);\n    const args = v1 ? (v1 as string).split(\", \") : [];\n    const instruction = lookupInstruction(opscode, args);\n    return { position, instruction, args };\n  }\n\n  throw new Error(`Cannot parse line ${line}`);\n};\n\nexport const methodParser: MethodParser = {\n  parse(\n    constantPool: Constant[],\n    stack: number,\n    locals: number,\n    args_size: number,\n    input: string\n  ) {\n    const code = input\n      .split(\"\\n\")\n      .map(s => s.trim())\n      .filter(s => s !== \"\")\n      .map(s => createInstruction(s));\n\n    return new MethodBodyImpl(stack, locals, args_size, code);\n  }\n};\n","import { MethodBody } from \"./../models/input\";\nimport { constantPoolParser } from \"./impl/constant-parser\";\nimport { methodParser } from \"./impl/instruction-parser\";\n\nexport const consts = `   #1 = Methodref          #6.#18         // java/lang/Object.\"<init>\":()V\n   #2 = Fieldref           #19.#20        // java/lang/System.out:Ljava/io/PrintStream;\n   #3 = Methodref          #5.#21         // _01_plop/Plop.plop:(I)I\n   #4 = Methodref          #22.#23        // java/io/PrintStream.println:(I)V\n   #5 = Class              #24            // _01_plop/Plop\n   #6 = Class              #25            // java/lang/Object\n   #7 = Utf8               <init>\n   #8 = Utf8               ()V\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               plop\n  #12 = Utf8               (I)I\n  #13 = Utf8               StackMapTable\n  #14 = Utf8               main\n  #15 = Utf8               ([Ljava/lang/String;)V\n  #16 = Utf8               SourceFile\n  #17 = Utf8               Plop.java\n  #18 = NameAndType        #7:#8          // \"<init>\":()V\n  #19 = Class              #26            // java/lang/System\n  #20 = NameAndType        #27:#28        // out:Ljava/io/PrintStream;\n  #21 = NameAndType        #11:#12        // plop:(I)I\n  #22 = Class              #29            // java/io/PrintStream\n  #23 = NameAndType        #30:#31        // println:(I)V\n  #24 = Utf8               _01_plop/Plop\n  #25 = Utf8               java/lang/Object\n  #26 = Utf8               java/lang/System\n  #27 = Utf8               out\n  #28 = Utf8               Ljava/io/PrintStream;\n  #29 = Utf8               java/io/PrintStream\n  #30 = Utf8               println\n  #31 = Utf8               (I)V`;\n\nconst factorialCode = `0: iconst_1\n1: istore_1\n2: iconst_2\n3: istore_2\n4: iload_2\n5: iload_0\n6: if_icmpgt     19\n9: iload_1\n10: iload_2\n11: imul\n12: istore_1\n13: iinc          2, 1\n16: goto          4\n19: iload_1\n20: ireturn`;\n\nconst mainCode = ` 0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n3: iconst_5\n4: invokestatic  #3                  // Method plop:(I)I\n7: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V\n10: return`;\n\nexport const constantPool = constantPoolParser.parse(consts);\n\nexport const sample = new Map<string, MethodBody>()\n  .set(\n    \"Method plop:(I)I\",\n    methodParser.parse(constantPool, 2, 3, 1, factorialCode)\n  )\n  .set(\"main\", methodParser.parse(constantPool, 2, 1, 1, mainCode));\n","import { html, TemplateResult } from \"lit-html\";\n\nimport { Constant, InstructionInstance } from \"../models/input\";\n\nexport const renderConstantPool = (constants: string): TemplateResult =>\n  html`\n    <details>\n      <summary>Constant Pool</summary>\n      <div class=\"constants\">${constants}</div>\n    </details>\n  `;\n\n// FIXME Frame, stack, locals, ... current step\nexport const renderMethodCode = (\n  code: InstructionInstance[],\n  position: number\n): TemplateResult => {\n  const classes = (inst: InstructionInstance) =>\n    [\n      inst.instruction.type ? `inst-${inst.instruction.type}` : \"\",\n      position === inst.position ? \"selected\" : \"\"\n    ]\n      .filter(s => s !== \"\")\n      .join(\" \");\n  return html`\n    <ul class=\"code\">\n      ${code.map(\n        inst => html`\n  <li class=\"${classes(inst)}\">\n    <div class=\"position\">${inst.position}</div>\n    <div class=\"code\">${inst.instruction.code}</div>\n    <div class=\"args\">${inst.args}</div>\n  </li>\n</ul>`\n      )}\n    </ul>\n  `;\n};\n","import Any = jasmine.Any;\nimport { Type } from \"../models/input\";\n\nconst renderArrayValue = (array: Any[]): string =>\n  array.length === 0\n    ? \"[]\"\n    : array.reduce(\n        (acc, elt) => (acc === \"\" ? `[ ${elt}` : `${acc}, ${elt}`),\n        \"\"\n      ) + \" ]\";\n\nexport const renderTypedValue = (type: Type, value: any): string => {\n  switch (type) {\n    case Type.Ref:\n      return `\n    ref: ${Array.isArray(value) ? renderArrayValue(value) : value}`;\n    default:\n      return value === null ? \"<null>\" : `${value}`;\n  }\n};\n","import { html, TemplateResult } from \"lit-html\";\n\nimport { LocalVariables } from \"../models/LocalVariables\";\nimport { Value } from \"../models/runtime\";\nimport { renderTypedValue } from \"./value\";\n\nconst renderLocalValue = (value: Value | null): TemplateResult =>\n  value\n    ? html`\n        <div class=\"type-${value.type}\" title=\"${value.value}\">\n          ${renderTypedValue(value.type, value.value)}\n        </div>\n      `\n    : html`\n        <div class=\"empty\"></div>\n      `;\n\nexport const renderLocals = (locals: LocalVariables): TemplateResult => html`\n  <div class=\"locals\">\n    <header>Locals</header>\n    <div>\n      ${locals.list.map(renderLocalValue)}\n    </div>\n  </div>\n`;\n","import { html, TemplateResult } from \"lit-html\";\n\nimport { OperandStack } from \"../models/OperandStack\";\nimport { Value } from \"../models/runtime\";\n\nconst renderStackValue = (value: Value | null): TemplateResult =>\n  value\n    ? html`\n        <div class=\"type-${value.type}\" title=\"${value.value}\">\n          ${value.value}\n        </div>\n      `\n    : html`\n        <div class=\"empty\"></div>\n      `;\n\nexport const renderStack = (stack: OperandStack): TemplateResult =>\n  html`\n    <div class=\"stack\">\n      <header>Stack</header>\n      <div>\n        ${stack.list.map(renderStackValue)}\n      </div>\n    </div>\n  `;\n","import { html, TemplateResult } from \"lit-html\";\n\nimport { Frame } from \"../models/Frame\";\nimport { Frames } from \"../models/Frames\";\nimport { Value } from \"../models/runtime\";\nimport { renderConstantPool, renderMethodCode } from \"./inputs\";\nimport { renderLocals } from \"./locals\";\nimport { renderStack } from \"./stack\";\nimport { renderTypedValue } from \"./value\";\n\nconst renderArgs = (args: Value[]): TemplateResult =>\n  html`\n    <span class=\"args\"\n      >${args.map(\n        ({ type, value }) =>\n          html`\n            <span class=\"type-${type}\">${renderTypedValue(type, value)}</span>\n          `\n      )}</span\n    >\n  `;\n\nconst renderFrame = (frame: Frame, current: boolean): TemplateResult =>\n  html`\n    <article class=\"frame ${current ? \"current\" : \"\"}\">\n      <header>${frame.name} ${renderArgs(frame.args)}</header>\n      ${renderMethodCode(frame.methodBody.code, frame.position)}\n      ${renderStack(frame.stack)} ${renderLocals(frame.locals)}\n    </article>\n  `;\n\nexport const renderFrames = (\n  frames: Frames,\n  display: () => void\n): TemplateResult => html`\n  ${renderConstantPool(frames.constantPool)}\n  <details open class=\"frames\">\n    <summary>Frames</summary>\n    <menu class=\"next\">\n      ${frames.frames.length > 0\n        ? html`\n            <button type=\"button\" @click=${display}>\n               Next\n            </button>\n          `\n        : ``}\n    </menu>\n    <div>\n      ${frames.frames.map(frame =>\n        renderFrame(frame, frame === frames.currentFrame)\n      )}\n    </div>\n  </details>\n`;\n","import { render } from \"lit-html\";\n\nimport { Frames } from \"./models/Frames\";\nimport { consts, sample } from \"./parser/sample\";\nimport { renderFrames } from \"./templates/frame\";\n\ndeclare global {\n  interface Window {\n    catnip: any;\n  }\n}\n\nconst frames = new Frames(consts, sample);\n\nexport const catnip = (elt: HTMLElement | null): void => {\n  if (elt !== null) {\n    const display = () => {\n      frames.next();\n      catnip(elt);\n    };\n    render(renderFrames(frames, display), elt);\n  } else {\n    console.warn(\"Cannot mount element:\", elt);\n  }\n};\n\nwindow.catnip = catnip;\n"]}